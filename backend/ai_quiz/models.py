from django.db import models
from django.utils import timezone
from django.core.exceptions import ValidationError
from users.models import User


class LectureSlide(models.Model):
    """Lecture slides uploaded by lecturers"""
    topic = models.ForeignKey(
        'courses.Topic',
        on_delete=models.CASCADE,
        related_name='lecture_slides'
    )
    title = models.CharField(max_length=200)
    slide_file = models.FileField(
        upload_to='lecture_slides/',
        help_text='Upload PDF lecture slides'
    )
    extracted_text = models.TextField(
        blank=True,
        help_text='Automatically extracted text from PDF'
    )
    uploaded_by = models.ForeignKey(
        'users.User',
        on_delete=models.CASCADE,
        limit_choices_to={'user_type': 'lecturer'}
    )
    questions_generated = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']
    
    def clean(self):
        """Validate file format"""
        if self.slide_file and not self.slide_file.name.lower().endswith('.pdf'):
            raise ValidationError('Only PDF files are allowed.')
    
    def save(self, *args, **kwargs):
        self.clean()
        super().save(*args, **kwargs)
        
        # Extract text from PDF after saving
        if self.slide_file and not self.extracted_text:
            self.extract_text_from_pdf()
    
    def extract_text_from_pdf(self):
        """Extract text from uploaded PDF"""
        try:
            import PyPDF2
            
            with open(self.slide_file.path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                text_content = []
                
                for page in pdf_reader.pages:
                    text_content.append(page.extract_text())
                
                self.extracted_text = '\n'.join(text_content)
                self.save(update_fields=['extracted_text'])
                
        except Exception as e:
            print(f"Error extracting text from PDF: {e}")
            # Fallback: set a placeholder text
            self.extracted_text = "Text extraction failed. Please check PDF format."
            self.save(update_fields=['extracted_text'])
    
    def __str__(self):
        return f"{self.topic.course.code} - {self.title}"


class AdaptiveQuiz(models.Model):
    """Adaptive quizzes generated from lecture slides"""
    DIFFICULTY_CHOICES = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard')
    ]
    
    STATUS_CHOICES = [
        ('draft', 'Draft'),
        ('under_review', 'Under Review'), 
        ('published', 'Published'),
        ('rejected', 'Rejected'),
    ]
    
    lecture_slide = models.ForeignKey(
        LectureSlide,
        on_delete=models.CASCADE,
        related_name='adaptive_quizzes'
    )
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_CHOICES)
    
    # Store Claude-generated questions as JSON
    questions_data = models.JSONField(
        help_text='Questions, options, and explanations generated by Claude'
    )
    
    # Moderation fields
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='draft')
    reviewed_by = models.ForeignKey(
        'users.User',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='reviewed_quizzes',
        limit_choices_to={'user_type': 'lecturer'}
    )
    reviewed_at = models.DateTimeField(null=True, blank=True)
    review_notes = models.TextField(blank=True)
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['difficulty', '-created_at']
        unique_together = ('lecture_slide', 'difficulty')
    
    def get_questions(self):
        """Get questions as Python dict"""
        return self.questions_data if isinstance(self.questions_data, dict) else {}
    
    def get_question_count(self):
        """Get number of questions in this quiz"""
        questions = self.get_questions()
        return len(questions.get('questions', []))
    
    @property
    def is_available_to_students(self):
        """Check if quiz is available to students"""
        return self.status == 'published' and self.is_active
    
    def __str__(self):
        return f"{self.lecture_slide.title} - {self.difficulty.title()} ({self.status})"


class StudentAdaptiveProgress(models.Model):
    """Track student progress through adaptive quizzes"""
    student = models.ForeignKey(
        'users.User',
        on_delete=models.CASCADE,
        limit_choices_to={'user_type': 'student'},
        related_name='adaptive_progress'
    )
    adaptive_quiz = models.ForeignKey(
        AdaptiveQuiz,
        on_delete=models.CASCADE,
        related_name='student_progress'
    )
    
    # Attempt tracking
    attempts_count = models.PositiveIntegerField(default=0)
    best_score = models.FloatField(default=0.0)
    latest_score = models.FloatField(default=0.0)
    
    # Progress tracking
    completed = models.BooleanField(default=False)
    unlocked_next_level = models.BooleanField(default=False)
    explanation_viewed = models.BooleanField(default=False)
    
    # Timestamps
    first_attempt_at = models.DateTimeField(auto_now_add=True)
    last_attempt_at = models.DateTimeField(auto_now=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        unique_together = ('student', 'adaptive_quiz')
        ordering = ['-last_attempt_at']
    
    def can_attempt(self):
        """Check if student can attempt this quiz"""
        # Always allow attempts (unlimited tries)
        return True
    
    def should_show_explanation(self):
        """Check if explanation should be shown after 3 failed attempts"""
        return self.attempts_count >= 3 and self.latest_score < 50
    
    def mark_completed(self, score):
        """Mark quiz as completed with given score"""
        self.latest_score = score
        if score > self.best_score:
            self.best_score = score
        
        # Mark as completed if score >= 50%
        if score >= 50 and not self.completed:
            self.completed = True
            self.completed_at = timezone.now()
            
            # Check if next level should be unlocked
            self.check_unlock_next_level()
    
    def check_unlock_next_level(self):
        """Check if next difficulty level should be unlocked"""
        if not self.completed:
            return
        
        current_difficulty = self.adaptive_quiz.difficulty
        lecture_slide = self.adaptive_quiz.lecture_slide
        
        # Define progression path
        progression = {
            'easy': 'medium',
            'medium': 'hard',
            'hard': None  # No next level
        }
        
        next_difficulty = progression.get(current_difficulty)
        if next_difficulty:
            try:
                next_quiz = AdaptiveQuiz.objects.get(
                    lecture_slide=lecture_slide,
                    difficulty=next_difficulty
                )
                
                # Create or update progress for next level
                next_progress, created = StudentAdaptiveProgress.objects.get_or_create(
                    student=self.student,
                    adaptive_quiz=next_quiz,
                    defaults={'unlocked_next_level': True}
                )
                
                if not created:
                    next_progress.unlocked_next_level = True
                    next_progress.save()
                
                self.unlocked_next_level = True
                
            except AdaptiveQuiz.DoesNotExist:
                pass  # Next level doesn't exist yet
    
    def __str__(self):
        return f"{self.student.get_full_name()} - {self.adaptive_quiz}"


class AdaptiveQuizAttempt(models.Model):
    """Individual attempts at adaptive quizzes"""
    progress = models.ForeignKey(
        StudentAdaptiveProgress,
        on_delete=models.CASCADE,
        related_name='attempts'
    )
    
    # Attempt details
    answers_data = models.JSONField(
        help_text='Student answers for this attempt'
    )
    score_percentage = models.FloatField()
    time_taken = models.DurationField(null=True, blank=True)
    
    # Timestamps
    started_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-started_at']
    
    def get_answers(self):
        """Get answers as Python dict"""
        return self.answers_data if isinstance(self.answers_data, dict) else {}
    
    def __str__(self):
        return f"Attempt {self.id} - {self.progress.student.get_full_name()} ({self.score_percentage}%)"